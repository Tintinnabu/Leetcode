1, map
2, ListNode
3, map
*4, 二分查找
*5, dp || 中心扩展法
*10, dp状态转移
11, double point 
15, sort + double point
17, backtrack || queue
19, fast and slow point
20, 符号匹配，stack，左括号进栈，右括号匹配出栈
21, 迭代 || 递归
22, dfs
23, 小根堆 || 迭代两两合并 || 归并两两合并(分治)
31, 规律：下一个数比当前数大, 下一个数增加的幅度尽可能的小
32, dp 找到')'就开始匹配
*33, 二分查找, 注意边界
*34, 二分查找, 注意边界
39, 回溯 + 剪枝
*42, dp || double points || 单调栈
46, 回溯
48, 转置 + 中轴对称
49, 正整数唯一分解定理（质数积）
53, dp
55, dp 记录当前能到的最大位置
56, 按interval[0]从小到大排序,再两两合并
62, dp
64, dp
70, dp (斐波那契数列)
*72, 
75, 三色旗 快排
76, 滑动窗口 数组存储状态
78, 回溯
79, 回溯 + 剪枝
*84,
*85,
94, 迭代（栈） || 递归
96, dp
98, 递归 中序遍历 比较curval 与 preval 
101, 递归 || 迭代栈
102, dfs || bfs
104, dfs || bfs 
105, 利用前序、中序的规律
114, 右左根递归遍历，保存pre节点作为当前节点的右节点， 当前节点的左节点删除
121, 
124, 递归, 中途计算以该点为root的最大路径和
*128,
136, 位异或
139, dp + 记忆化回溯
141, 快慢指针找重合
142, 快慢指针找重合，重合后快指针回到起始位置，找到下一次重合点
146, 双端指针，lru放在头指针后节点，溢出移除尾指针前节点
148, 归并
152, dp
155, min更新时将旧值压入,pop出min时，把旧min值也pop出来
160, 双指针，到终点交换起点
169, 摩尔投票法
198,
200, dfs
206, 迭代 || 递归
*207, bfs 更新入度信息 || dfs判断是否有环
208, 前缀树
215, 快排
221, dp
226, 二叉树递归
234，快慢指针，翻转前半或者后半部分顺序
236，二叉树 dfs 后序遍历
238, 左边积 * 右边积
*239,
240, 左下往右上搜索
279，
283，简单题
*287，
297，
*300, dp || dp + 二分查找
301, 
309,
312,
322,
337,
338, dp + 奇偶性
347,
*394, 双栈，一个存储当前字符串，一个存储当前重复次数
399,
406,
*416,
*437, 递归 || 递归 + 记忆化路径和 + 回溯
438,
*448,
461, 异或 找bit = 1的个数
494,
538,
543,
560,
581,
617, 递归 先序遍历
621,
647,
739,